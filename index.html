<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NFS: Cyberpunk Drift Redux (Multiplayer)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --dark-bg: #050510;
            --ui-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--dark-bg);
            font-family: 'Orbitron', sans-serif;
            color: white;
            user-select: none;
            -webkit-touch-callout: none; /* iOS Safari */
            touch-action: none; /* Disable native touch gestures */
        }

        /* Оверлей ошибок */
        #error-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.95);
            color: #ff5555;
            z-index: 9999;
            padding: 40px;
            box-sizing: border-box;
            font-family: monospace;
            white-space: pre-wrap;
        }

        #game-ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        /* HUD */
        #hud {
            display: none;
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            z-index: 10;
        }
        .hud-value { font-size: 2.5rem; font-weight: 900; color: var(--neon-blue); text-shadow: 0 0 10px var(--neon-blue); }
        .hud-label { font-size: 0.8rem; color: #aaa; letter-spacing: 2px; }
        
        #players-count {
            font-size: 0.9rem;
            color: var(--neon-pink);
            margin-top: 5px;
        }

        #nitro-bar-container {
            display: none;
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: #333;
            border: 2px solid #555;
            transform: skewX(-20deg);
            z-index: 10;
        }
        #nitro-bar {
            width: 0%;
            height: 100%;
            background: var(--neon-pink);
            box-shadow: 0 0 15px var(--neon-pink);
            transition: width 0.1s;
        }

        /* Мобильное управление */
        #mobile-controls {
            display: none; /* Включается JS если тач */
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        .touch-btn {
            position: absolute;
            bottom: 40px;
            width: 80px; height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(4px);
            transition: background 0.1s;
        }
        .touch-btn:active { background: rgba(0, 243, 255, 0.3); border-color: var(--neon-blue); color: white; }

        #btn-left { left: 30px; }
        #btn-right { left: 130px; }
        #btn-nitro { right: 30px; width: 90px; height: 90px; border-color: var(--neon-pink); color: var(--neon-pink); font-weight: bold; font-size: 16px; }
        #btn-nitro:active { background: rgba(255, 0, 255, 0.3); }

        /* Меню и Гараж */
        #main-menu, #game-over {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--ui-bg);
            padding: 40px;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px var(--neon-blue);
            text-align: center;
            pointer-events: auto;
            max-width: 500px;
            width: 90%;
            z-index: 50;
        }

        h1 { margin: 0 0 20px; font-size: 3rem; color: var(--neon-blue); text-transform: uppercase; font-style: italic; }
        h2 { color: var(--neon-pink); }
        
        button {
            background: transparent;
            border: 2px solid white;
            color: white;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            margin-top: 20px;
            transition: 0.3s;
            text-transform: uppercase;
        }
        button:hover { background: white; color: black; box-shadow: 0 0 15px white; }

        .garage-controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .color-btn {
            width: 40px; height: 40px;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .color-btn:hover { transform: scale(1.2); }

        #controls-hint {
            margin-top: 20px;
            font-size: 0.8rem;
            color: #888;
        }
        
        #connection-status {
            font-size: 0.7rem;
            color: #666;
            margin-top: 10px;
        }
    </style>

    <!-- 1. АРХИТЕКТУРА: Import Map для Three.js и Firebase -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- 1. АРХИТЕКТУРА: Ловушка ошибок -->
    <script>
        window.onerror = function(message, source, lineno, colno, error) {
            const overlay = document.getElementById('error-overlay');
            overlay.style.display = 'block';
            overlay.innerHTML = `CRITICAL SYSTEM FAILURE:\n\n${message}\nLine: ${lineno}\nSource: ${source}`;
            console.error(error);
        };
    </script>
</head>
<body>

    <div id="error-overlay"></div>

    <div id="game-ui">
        <div id="hud">
            <div class="hud-value" id="speed-display">0</div>
            <div class="hud-label">KM/H</div>
            <div class="hud-value" id="score-display" style="font-size: 1.5rem; margin-top:10px; color:white;">0</div>
            <div class="hud-label">SCORE</div>
            <div id="players-count">ONLINE: 1</div>
        </div>
        <div id="nitro-bar-container"><div id="nitro-bar"></div></div>

        <!-- Мобильное управление -->
        <div id="mobile-controls">
            <div class="touch-btn" id="btn-left">◀</div>
            <div class="touch-btn" id="btn-right">▶</div>
            <div class="touch-btn" id="btn-nitro">NITRO</div>
        </div>

        <div id="main-menu">
            <h1>NEON DRIFT</h1>
            <p>ГАРАЖ / НАСТРОЙКИ</p>
            
            <div class="garage-controls">
                <div>
                    <p style="font-size:0.8rem">КУЗОВ</p>
                    <div style="display:flex; gap:10px;">
                        <div class="color-btn" style="background:#ff0000" onclick="updateCarColor(0xff0000)"></div>
                        <div class="color-btn" style="background:#00f3ff" onclick="updateCarColor(0x00f3ff)"></div>
                        <div class="color-btn" style="background:#ffffff" onclick="updateCarColor(0xffffff)"></div>
                        <div class="color-btn" style="background:#111111" onclick="updateCarColor(0x111111)"></div>
                    </div>
                </div>
                <div>
                    <p style="font-size:0.8rem">НЕОН</p>
                    <div style="display:flex; gap:10px;">
                        <div class="color-btn" style="background:#ff00ff" onclick="updateNeonColor(0xff00ff)"></div>
                        <div class="color-btn" style="background:#00ff00" onclick="updateNeonColor(0x00ff00)"></div>
                        <div class="color-btn" style="background:#ffff00" onclick="updateNeonColor(0xffff00)"></div>
                    </div>
                </div>
            </div>

            <button onclick="startGame()">ГОНКА</button>
            <div id="controls-hint">WASD / Стрелки - Управление<br>ПРОБЕЛ - Нитро</div>
            <div id="connection-status">Connecting to server...</div>
        </div>

        <div id="game-over" style="display: none;">
            <h1 style="color:red">CRASHED</h1>
            <h2 id="final-score">SCORE: 0</h2>
            <button onclick="resetGame()">RETRY</button>
            <button onclick="quitToMenu()" style="margin-left: 10px; font-size: 1rem; padding: 15px 20px;">MENU</button>
        </div>
    </div>

    <!-- Основной скрипт модуля -->
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- FIREBASE IMPORTS (CDN) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, deleteDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

        // --- GLOBALS ---
        let scene, camera, renderer, composer;
        let playerCar;
        let roadSegments = [];
        let trafficCars = [];
        let rivalMeshes = {}; // Map of userId -> Mesh
        let clock = new THREE.Clock();
        
        // Firebase Globals
        let db, auth, currentUserId;
        let lastSyncTime = 0;
        let rivalsData = {}; // Map of userId -> data
        let raceCollectionRef; // Dynamic reference based on env
        
        // --- HYBRID CONFIGURATION ---
        const FALLBACK_CONFIG = {
            apiKey: "AIzaSyAWV097BE56m2YVNi2D494dyXK41j9V5bE",
            authDomain: "messanger-b0b91.firebaseapp.com",
            projectId: "messanger-b0b91",
            storageBucket: "messanger-b0b91.firebasestorage.app",
            messagingSenderId: "895029700922",
            appId: "1:895029700922:web:35b5f3999f2b3641aa4803",
            measurementId: "G-RQ7GYZPT2G"
        };

        // Состояние игры
        const gameState = {
            active: false,
            speed: 0,
            baseSpeed: 0,
            maxSpeed: 180,
            nitroMaxSpeed: 280,
            nitro: 100,
            score: 0,
            distance: 0, // Абсолютная дистанция для мультиплеера
            lane: 0,
            targetX: 0,
            carColor: 0x00f3ff,
            neonColor: 0xff00ff
        };

        const WORLD_CONFIG = {
            segmentLength: 20,
            segmentCount: 20,
            roadWidth: 14,
            laneWidth: 4,
            fogDist: 150
        };

        const CONTROLS = {
            left: false,
            right: false,
            nitro: false
        };

        // --- INIT ---
        async function init() {
            // Setup Firebase (Hybrid Mode)
            let isCanvasEnv = false;
            let app;

            try {
                // 1. Попытка загрузить конфигурацию среды (для Canvas)
                if (typeof __firebase_config !== 'undefined') {
                    const envConfig = JSON.parse(__firebase_config);
                    app = initializeApp(envConfig);
                    isCanvasEnv = true;
                    console.log("Environment: Canvas/Internal");
                } else {
                    // Если __firebase_config нет, вызываем ошибку, чтобы перейти в catch
                    throw new Error("Env config missing");
                }
            } catch (e) {
                // 2. Фолбэк: Использование вашей жестко заданной конфигурации (для внешнего мира)
                app = initializeApp(FALLBACK_CONFIG);
                isCanvasEnv = false;
                console.log("Environment: External/Public");
            }

            try {
                // const analytics = getAnalytics(app); // Analytics optional
                db = getFirestore(app);
                auth = getAuth(app);
                
                // AUTH LOGIC
                if (isCanvasEnv) {
                    // Внутри среды: Используем токены если есть, и специфический путь
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                    
                    // Установка пути к коллекции для Canvas (Strict Path)
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    raceCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'nfs_multiplayer_races');

                } else {
                    // Снаружи: Обычная анонимная авторизация и обычный путь
                    await signInAnonymously(auth);
                    
                    // Установка пути к коллекции для External (Simple Path)
                    raceCollectionRef = collection(db, 'nfs_multiplayer_races');
                }

                currentUserId = auth.currentUser.uid;
                document.getElementById('connection-status').innerText = "CONNECTED: " + currentUserId.substring(0,6);
                document.getElementById('connection-status').style.color = "#00ff00";
                
                initMultiplayerListener();
            } catch (e) {
                console.error("Firebase Auth/Init Error:", e);
                document.getElementById('connection-status').innerText = "OFFLINE MODE (" + e.message + ")";
            }

            // Setup Mobile Check
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                document.getElementById('mobile-controls').style.display = 'block';
                setupTouchControls();
            }

            init3D();
            animate();
        }

        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 3, 8);
            camera.lookAt(0, 0, -20);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x000044, 2.0);
            scene.add(ambientLight);
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.5);
            scene.add(hemiLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createPlayerCar();
            createRoad();
            
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }

        // --- CAR CREATION (REUSABLE) ---
        function createCarMesh(color, neonColor) {
            const carGroup = new THREE.Group();

            const shape = new THREE.Shape();
            shape.moveTo(-1.2, 0); shape.lineTo(1.2, 0); shape.lineTo(1.3, 0.3);
            shape.lineTo(0.6, 0.75); shape.lineTo(-0.4, 0.75); shape.lineTo(-1.1, 0.4);
            shape.lineTo(-1.25, 0.3); shape.lineTo(-1.2, 0);

            const extrudeSettings = { steps: 1, depth: 1.6, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 2 };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center();

            const material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.8, roughness: 0.2 });
            const chassis = new THREE.Mesh(geometry, material);
            chassis.rotation.y = -Math.PI / 2;
            chassis.position.y = 0.5;
            carGroup.add(chassis);
            carGroup.userData.chassisMat = material;

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.4, 24);
            wheelGeo.rotateZ(Math.PI / 2);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const positions = [{x:-0.7, z:-0.8}, {x:0.7, z:-0.8}, {x:-0.7, z:0.8}, {x:0.7, z:0.8}];
            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.position.set(pos.x, 0.35, pos.z);
                carGroup.add(wheel);
            });

            // Neon
            const neonLight = new THREE.PointLight(neonColor, 10, 5);
            neonLight.position.set(0, 0.2, 0);
            carGroup.add(neonLight);
            carGroup.userData.neon = neonLight;

            // Tail lights
            const tailGeo = new THREE.BoxGeometry(0.8, 0.1, 0.1);
            const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const tailLight = new THREE.Mesh(tailGeo, tailMat);
            tailLight.position.set(0, 0.6, 1.1);
            carGroup.add(tailLight);

            return carGroup;
        }

        function createPlayerCar() {
            playerCar = createCarMesh(gameState.carColor, gameState.neonColor);
            
            // Add headlights only for player
            const spotLeft = new THREE.SpotLight(0xffffff, 50);
            spotLeft.position.set(-0.5, 0.6, -1.0);
            spotLeft.target.position.set(-0.5, 0, -10);
            spotLeft.angle = 0.5; spotLeft.penumbra = 0.5;
            playerCar.add(spotLeft); playerCar.add(spotLeft.target);

            const spotRight = new THREE.SpotLight(0xffffff, 50);
            spotRight.position.set(0.5, 0.6, -1.0);
            spotRight.target.position.set(0.5, 0, -10);
            spotRight.angle = 0.5; spotRight.penumbra = 0.5;
            playerCar.add(spotRight); playerCar.add(spotRight.target);

            scene.add(playerCar);
        }

        // --- WORLD GENERATION ---
        function createRoad() {
            for (let i = 0; i < WORLD_CONFIG.segmentCount; i++) {
                const segment = new THREE.Group();
                const zPos = -i * WORLD_CONFIG.segmentLength;

                const roadGeo = new THREE.PlaneGeometry(WORLD_CONFIG.roadWidth, WORLD_CONFIG.segmentLength);
                roadGeo.rotateX(-Math.PI / 2);
                const roadMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
                const road = new THREE.Mesh(roadGeo, roadMat);
                
                const lineGeo = new THREE.PlaneGeometry(0.2, WORLD_CONFIG.segmentLength / 2);
                lineGeo.rotateX(-Math.PI / 2);
                const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const lineL = new THREE.Mesh(lineGeo, lineMat); lineL.position.set(-WORLD_CONFIG.laneWidth/2, 0.02, 0);
                const lineR = new THREE.Mesh(lineGeo, lineMat); lineR.position.set(WORLD_CONFIG.laneWidth/2, 0.02, 0);

                segment.add(road); segment.add(lineL); segment.add(lineR);
                const gridHelper = new THREE.GridHelper(60, 10, 0x00f3ff, 0x110022);
                gridHelper.position.y = -0.1;
                segment.add(gridHelper);

                if (Math.random() > 0.3) createBuilding(segment, -20);
                if (Math.random() > 0.3) createBuilding(segment, 20);

                segment.position.z = zPos;
                scene.add(segment);
                roadSegments.push(segment);
            }
        }

        function createBuilding(parent, xOffset) {
            const height = 10 + Math.random() * 40;
            const width = 5 + Math.random() * 10;
            const geo = new THREE.BoxGeometry(width, height, width);
            const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x220033 }));
            const mesh = new THREE.Mesh(geo, mat);
            mesh.add(line);
            mesh.position.set(xOffset, height/2, 0);
            parent.add(mesh);
        }

        function spawnTraffic() {
            if (trafficCars.length > 5) return;
            const group = new THREE.Group();
            
            const bodyGeo = new THREE.BoxGeometry(2, 1.2, 4);
            const bodyMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.5 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            group.add(body);

            const tailGeo = new THREE.BoxGeometry(1.8, 0.2, 0.1);
            const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const tail = new THREE.Mesh(tailGeo, tailMat);
            tail.position.set(0, 0.8, 2.01);
            group.add(tail);

            const laneIndex = Math.floor(Math.random() * 3) - 1;
            group.position.set(laneIndex * WORLD_CONFIG.laneWidth, 0, -100 - Math.random() * 50);
            
            group.userData = { lane: laneIndex, speed: 60 + Math.random() * 40 };
            scene.add(group);
            trafficCars.push(group);
        }

        // --- FIREBASE LOGIC ---
        function initMultiplayerListener() {
            if (!db || !raceCollectionRef) return;
            
            // Слушаем обновления всех игроков, используя динамическую ссылку
            onSnapshot(raceCollectionRef, (snapshot) => {
                const count = snapshot.size;
                document.getElementById('players-count').innerText = "ONLINE: " + count;

                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const uid = change.doc.id;
                    if (uid === currentUserId) return; // ignore self

                    if (change.type === "added" || change.type === "modified") {
                        rivalsData[uid] = data;
                        updateRivalMesh(uid, data);
                    }
                    if (change.type === "removed") {
                        delete rivalsData[uid];
                        removeRivalMesh(uid);
                    }
                });
            }, (error) => {
                console.warn("Firestore listener error (possibly permissions or offline):", error);
            });

            // Очистка при выходе
            window.addEventListener('beforeunload', () => {
                if(currentUserId) deleteDoc(doc(raceCollectionRef, currentUserId));
            });
        }

        function syncPlayerState() {
            if (!db || !currentUserId || !gameState.active || !raceCollectionRef) return;
            
            const now = Date.now();
            if (now - lastSyncTime > 100) { // Sync every 100ms
                setDoc(doc(raceCollectionRef, currentUserId), {
                    x: gameState.lane, // Lane index
                    z: gameState.distance, // Absolute distance
                    color: gameState.carColor,
                    neon: gameState.neonColor,
                    lastSeen: serverTimestamp()
                }).catch(e => console.warn("Sync fail", e));
                lastSyncTime = now;
            }
        }

        function updateRivalMesh(uid, data) {
            let mesh = rivalMeshes[uid];
            // Создаем, если нет
            if (!mesh) {
                mesh = createCarMesh(data.color, data.neon);
                // Делаем полупрозрачным "призраком"
                mesh.traverse(c => {
                    if(c.isMesh) {
                        c.material.transparent = true;
                        c.material.opacity = 0.6;
                    }
                });
                scene.add(mesh);
                rivalMeshes[uid] = mesh;
            }
            // Позиция будет обновлена в animate() на основе gameState.distance
        }

        function removeRivalMesh(uid) {
            if (rivalMeshes[uid]) {
                scene.remove(rivalMeshes[uid]);
                delete rivalMeshes[uid];
            }
        }

        function updateRivals(delta) {
            for (const uid in rivalsData) {
                const data = rivalsData[uid];
                const mesh = rivalMeshes[uid];
                if (!mesh) continue;

                // X position (lane) interpolation
                const targetX = data.x * WORLD_CONFIG.laneWidth;
                mesh.position.x = THREE.MathUtils.lerp(mesh.position.x, targetX, delta * 5);

                // Z position (Relative to player)
                const relativeZ = -(data.z - gameState.distance);
                mesh.position.z = THREE.MathUtils.lerp(mesh.position.z, relativeZ, delta * 10);
                
                // Tilt logic
                const tilt = (mesh.position.x - targetX) * 0.05;
                mesh.rotation.z = -tilt;
                mesh.rotation.y = (tilt * 0.5);
            }
        }

        // --- CONTROLS ---
        function setupTouchControls() {
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');
            const btnNitro = document.getElementById('btn-nitro');

            const handleTouch = (key, state) => (e) => {
                e.preventDefault();
                // Логика переключения полос для кнопок (tap behaviour)
                if (state && (key === 'left' || key === 'right')) {
                   if (key === 'left') changeLane(-1);
                   if (key === 'right') changeLane(1);
                }
                CONTROLS[key] = state;
            };

            btnLeft.addEventListener('touchstart', handleTouch('left', true));
            btnLeft.addEventListener('touchend', handleTouch('left', false));
            
            btnRight.addEventListener('touchstart', handleTouch('right', true));
            btnRight.addEventListener('touchend', handleTouch('right', false));

            btnNitro.addEventListener('touchstart', handleTouch('nitro', true));
            btnNitro.addEventListener('touchend', handleTouch('nitro', false));
        }

        function onKeyDown(e) {
            if (e.key === 'Escape') { window.quitToMenu(); return; }
            if (!gameState.active) return;
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': CONTROLS.up = true; break;
                case 's': case 'arrowdown': CONTROLS.down = true; break;
                case 'a': case 'arrowleft': changeLane(-1); break;
                case 'd': case 'arrowright': changeLane(1); break;
                case ' ': CONTROLS.nitro = true; break;
            }
        }
        function onKeyUp(e) {
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': CONTROLS.up = false; break;
                case 's': case 'arrowdown': CONTROLS.down = false; break;
                case ' ': CONTROLS.nitro = false; break;
            }
        }

        function changeLane(dir) {
            gameState.lane += dir;
            gameState.lane = Math.max(-1, Math.min(1, gameState.lane));
            gameState.targetX = gameState.lane * WORLD_CONFIG.laneWidth;
        }

        // --- EXPORTED UI FUNCTIONS ---
        window.updateCarColor = (hex) => {
            gameState.carColor = hex;
            if (playerCar && playerCar.userData.chassisMat) playerCar.userData.chassisMat.color.setHex(hex);
        };
        window.updateNeonColor = (hex) => {
            gameState.neonColor = hex;
            if (playerCar && playerCar.userData.neon) playerCar.userData.neon.color.setHex(hex);
        };
        window.startGame = () => {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('nitro-bar-container').style.display = 'block';
            gameState.active = true;
            gameState.speed = 0;
            gameState.score = 0;
            gameState.distance = 0;
            gameState.nitro = 100;
            trafficCars.forEach(c => scene.remove(c));
            trafficCars = [];
        };
        window.resetGame = () => {
            document.getElementById('game-over').style.display = 'none';
            gameState.lane = 0; playerCar.position.x = 0; gameState.targetX = 0;
            window.startGame();
        };
        window.quitToMenu = () => {
            gameState.active = false;
            document.getElementById('hud').style.display = 'none';
            document.getElementById('nitro-bar-container').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('main-menu').style.display = 'block';
        };

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const rawDelta = clock.getDelta();
            const delta = Math.min(rawDelta, 0.05);

            if (gameState.active) {
                updatePhysics(delta);
                updateTraffic(delta);
                updateEnvironment(delta);
                updateRivals(delta); // Multiplayer Sync
                syncPlayerState();
                updateUI();
            }

            composer.render();
        }

        function updatePhysics(delta) {
            let targetSpeed = 0;
            // Управление с клавиатуры или тачскрина
            if (CONTROLS.up || (('ontouchstart' in window) && !CONTROLS.down)) targetSpeed = gameState.maxSpeed; // Автогаз на мобилках?
            // Сделаем автогаз по умолчанию для всех, кроме тормоза
            targetSpeed = gameState.maxSpeed; 
            
            if (CONTROLS.down) targetSpeed = -20;

            if (CONTROLS.nitro && gameState.nitro > 0) {
                targetSpeed = gameState.nitroMaxSpeed;
                gameState.nitro -= 30 * delta;
                camera.fov = THREE.MathUtils.lerp(camera.fov, 75, delta * 2);
                camera.position.x += (Math.random() - 0.5) * 0.1;
                camera.position.y += (Math.random() - 0.5) * 0.1;
            } else {
                gameState.nitro = Math.min(100, gameState.nitro + 5 * delta);
                camera.fov = THREE.MathUtils.lerp(camera.fov, 60, delta * 2);
            }
            camera.updateProjectionMatrix();

            gameState.speed = THREE.MathUtils.lerp(gameState.speed, targetSpeed, delta * (CONTROLS.nitro ? 2.0 : 0.8));
            playerCar.position.x = THREE.MathUtils.lerp(playerCar.position.x, gameState.targetX, delta * 5);

            const tilt = (playerCar.position.x - gameState.targetX) * 0.05;
            playerCar.rotation.z = -tilt;
            playerCar.rotation.y = (tilt * 0.5);

            // Calc distance
            const moveDist = (gameState.speed * 0.3) * delta;
            gameState.distance += moveDist;
            gameState.score += moveDist * 0.1;
        }

        function updateEnvironment(delta) {
            const moveDist = (gameState.speed * 0.3) * delta; 
            roadSegments.forEach(segment => {
                segment.position.z += moveDist;
                if (segment.position.z > 20) {
                    segment.position.z -= WORLD_CONFIG.segmentLength * WORLD_CONFIG.segmentCount;
                }
            });
        }

        function updateTraffic(delta) {
            if (Math.random() < 0.02) spawnTraffic();
            const playerSpeed = gameState.speed;
            
            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const car = trafficCars[i];
                const relativeSpeed = (playerSpeed - car.userData.speed) * 0.3;
                car.position.z += relativeSpeed * delta;

                if (car.position.z > 30 || car.position.z < -250) {
                    scene.remove(car);
                    trafficCars.splice(i, 1);
                    continue;
                }
                if (Math.abs(car.position.z) < 2.5 && Math.abs(car.position.x - playerCar.position.x) < 1.5) {
                    gameOver();
                }
            }
        }

        function updateUI() {
            document.getElementById('speed-display').innerText = Math.floor(gameState.speed);
            document.getElementById('score-display').innerText = Math.floor(gameState.score);
            document.getElementById('nitro-bar').style.width = gameState.nitro + '%';
        }

        function gameOver() {
            gameState.active = false;
            document.getElementById('hud').style.display = 'none';
            document.getElementById('nitro-bar-container').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'none'; // Hide touch controls
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = 'SCORE: ' + Math.floor(gameState.score);
            
            // Clean up multiplayer self from DB immediately?
            if(currentUserId && raceCollectionRef) deleteDoc(doc(raceCollectionRef, currentUserId));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
